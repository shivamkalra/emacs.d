#+TITLE:   Shivam's Emacs Configuration
#+AUTHOR:  Shivam Kalra
#+EMAIL:   shivam.s.kalra@gmail.com
* References
My Emacs configuration is heavily inspired from various publicly
available Emacs configurations on the internet. I'm listing them
below:
1. [[http://p.writequit.org/org/settings.html][Lee's Emacs settings file]]
2. [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]]
3. [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs packages]]
* Introduction
This file is used by =org-babel= to load my personal Emacs
settings. This file is loaded from =init.el=:

#+BEGIN_SRC
  (require 'org)
  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC
** Package installation
I'm using [[https://github.com/cask/cask][Cask]] to manage dependencies for my local Emacs
configuration. It can be installed from [[https://github.com/cask/cask][here]].

Cask defines a domain-specific language for maintaining =elisp=
dependencies, which goes into my =~/.emacs.d/Cask= file. Run =cask
install= command in terminal from =~/.emacs.d/= directory to install
all the dependencies.

I'm using [[https://github.com/rdallasgray/pallet][Pallet]] to keep =~/.emacs.d/Cask= synchronized with packages
that are installed or removed through in-build Emacs package management
tool. Cask and Pallet is initialized from =init.el=:

#+BEGIN_SRC
  ;; Package Manager
  (require 'cask "~/.cask/cask.el")
  (cask-initialize)
  (require 'pallet)
  (pallet-mode t)
  ;; Keeps ~Cask~ file in sync with the packages
  (require 'pallet)
#+END_SRC
* Configuration
** Appearance, look and feel
*** Menu and toolbar
Disable all menu and toolbar to claim every little screen-space.

#+BEGIN_SRC emacs-lisp
 (progn
   (dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
     (when (fboundp mode) (funcall mode -1))))
#+END_SRC
*** Theme
I use =solarized-dark= theme for graphical Emacs and  =wombat= to run Emacs on
my =rxvt= terminal. I tend to use Emacs more in X system than terminal.

#+BEGIN_SRC emacs-lisp
  ;; solarized-dark on window-system
  ;; wombat on terminal
  (if (display-graphic-p)
      (progn
        ;; https://github.com/bbatsov/solarized-emacs/issues/87
        (setq solarized-use-variable-pitch nil)
        (load-theme 'solarized-dark t))
    (load-theme 'wombat t))
#+END_SRC
*** Fonts
I have been using [[http://openfontlibrary.org/en/font/fantasque-sans-mono][Fantasque Sans Mono]] lately and it looks pretty nice
to me.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
               '(font . "Fantasque Sans Mono-10:weight=black"))
#+END_SRC
*** Modelines
#+BEGIN_SRC emacs-lisp
  ;; line/column numbers in mode-line
  (line-number-mode)
  (column-number-mode)

  ;; show function in modeline
  (which-function-mode)
#+END_SRC
*** Misc.
Disable annoying bell sound and startup screen..geez..
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
  (setq ring-bell-function 'ignore)
#+END_SRC
** General settings
Things that cannot be categorized but applies everywhere in Emacs go here.
*** Global information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Shivam Kalra"
        user-mail-address "shivam.s.kalra@gmail.com"
        emacs-configuration-directory (file-name-directory  (file-truename "~/.emacs.d/init.el")))
#+END_SRC

Default directory to open a file is my =project= directory.
#+BEGIN_SRC emacs-lisp
  (setq default-directory "~/projects")
#+END_SRC
*** Backups and temporary files
By default Emacs saves backups of files in working directory. To
prevent Emacs cluttering current working directory with files ending
with =~= add this:

#+BEGIN_SRC emacs-lisp
  ;; savehist
  (setq savehist-additional-variables
        ;; also save my search entries
        '(search-ring regexp-search-ring)
        savehist-file "~/.emacs.d/savehist")
  (savehist-mode t)
  (setq-default save-place t)

  ;; delete-auto-save-files
  (setq delete-auto-save-files t)
  (setq backup-directory-alist
        '(("." . "~/.emacs.d/backups")))

  ;; delete old backups silently
  (setq delete-old-versions t)
#+END_SRC
*** Clipboard settings
Change the clipboard settings to better integrate into Linux:

#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t)
  ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

Save whatever's in the current (system) clipboard before replacing it with the
Emacs' text.

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC
*** View-mode and doc-view
Read-only viewing of files. Keybindings for paging through stuff
in a less/vim manner.

#+BEGIN_SRC emacs-lisp
  (use-package view
    :bind
    (("C-M-n" . View-scroll-half-page-forward)
     ("C-M-p" . View-scroll-half-page-backward))
    :config
    (progn
      ;; When in view-mode, the buffer is read-only:
      (setq view-read-only t)

      (defun View-goto-line-last (&optional line)
        "goto last line"
        (interactive "P")
        (goto-line (line-number-at-pos (point-max))))

      ;; less like
      (define-key view-mode-map (kbd "N") 'View-search-last-regexp-backward)
      (define-key view-mode-map (kbd "?") 'View-search-regexp-backward?)
      (define-key view-mode-map (kbd "g") 'View-goto-line)
      (define-key view-mode-map (kbd "G") 'View-goto-line-last)
      ;; vi/w3m like
      (define-key view-mode-map (kbd "h") 'backward-char)
      (define-key view-mode-map (kbd "j") 'next-line)
      (define-key view-mode-map (kbd "k") 'previous-line)
      (define-key view-mode-map (kbd "l") 'forward-char)))

  (use-package doc-view
    :config
    (define-key doc-view-mode-map (kbd "j")
      #'doc-view-next-line-or-next-page)
    (define-key doc-view-mode-map (kbd "k")
      #'doc-view-previous-line-or-previous-page)
    ;; use 'q' to kill the buffer, not just hide it
    (define-key doc-view-mode-map (kbd "q")
      #'kill-this-buffer))
#+END_SRC
*** Recent files
#+BEGIN_SRC emacs-lisp
(defun ido-recentf-open ()
  "Use `ido-completing-read' to \\[find-file] a recent file"
  (interactive)
  (if (find-file (ido-completing-read "Find recent file: " recentf-list))
      (message "Opening file...")
    (message "Aborting")))

(use-package recentf
  :init
  (recentf-mode t)
  :config
  (progn
    (setq recentf-max-saved-items 200
          recentf-max-menu-items 15)
    (bind-key "C-x C-r" 'ido-recentf-open)))
#+END_SRC

*** Disable Yes/No
Replacing =yes= or =no= prompt with =y= or =n=. It is much easier and less annoying.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** with-editor
Sets up the =with-editor= package so things that invoke =$EDITOR= will use the
current emacs if I'm already inside of emacs

#+BEGIN_SRC emacs-lisp
(use-package with-editor
  :init
  (progn
    (add-hook 'shell-mode-hook  'with-editor-export-editor)
    (add-hook 'eshell-mode-hook 'with-editor-export-editor)))
#+END_SRC

*** alert (notifications)
#+BEGIN_SRC emacs-lisp
(use-package alert)
#+END_SRC
*** Scratch buffer
#+BEGIN_SRC emacs-lisp
  (use-package scratch
    :defer t
    :bind (("C-c s" . scratch)))
#+END_SRC
** Terminals
*** multi-term
#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :bind (("C-c t" . multi-term))
    :config
    (progn
      (setq multi-term-default-dir default-directory)
      (setq multi-term-program "/bin/bash")))
#+END_SRC
** Navigation
*** Moving to beginning of file
#+BEGIN_SRC emacs-lisp
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'my/smarter-move-beginning-of-line)
#+END_SRC
*** Windmove - jumping between windows
#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :config
    (progn
      (windmove-default-keybindings)))
#+END_SRC
*** Ace jump
#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :config (eval-after-load "ace-jump-mode" '(ace-jump-mode-enable-mark-sync))
    :bind (("C-c SPC" . ace-jump-mode)
           ("C-c M-SPC" . ace-jump-line-mode)))
#+END_SRC
*** Ace window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("M-p" . ace-window))
    :config (progn
              (setq aw-keys '(?q ?w ?e ?a ?s ?d ?z ?x ?c))
              (setq aw-background t)
              ;; ignoring neo-tree
              (setq aw-ignore-on t)
              (add-to-list 'aw-ignored-buffers " *NeoTree*")))
#+END_SRC
*** Save place
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (setq-default save-place t)
    (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC
** Interface enhacements
*** smooth-scrolling
Smooth scrolling means when you hit =C-n= to go to the next line at the bottom
of the page, instead of doing a page-down, it shifts down by a single line. The
margin means that much space is kept between the cursor and the bottom of the
buffer.

#+BEGIN_SRC emacs-lisp
(use-package smooth-scrolling
  :config
  (setq smooth-scroll-margin 4))
#+END_SRC
*** ido-mode
First, turn on ido-mode everywhere, and if flx-ido is installed, enable it
everywhere as well.

Ido gives really nice completion while flx-ido makes everything more flexible
instead of rigid completions

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :init (ido-mode t)
    :config
    (progn
      (setq ido-use-virtual-buffers nil
            ;; this setting causes weird TRAMP connections, don't set it!
            ;;ido-enable-tramp-completion nil
            ido-enable-flex-matching t
            ido-auto-merge-work-directories-length nil
            ido-create-new-buffer 'always
            ido-use-filename-at-point 'guess
            ido-max-prospects 10)))

  (use-package flx-ido
    :init (flx-ido-mode t)
    :config
    (setq ido-use-faces nil))

  (use-package ido-vertical-mode
    :init (ido-vertical-mode t))

  (use-package ido-ubiquitous
    :init (ido-ubiquitous-mode t))
#+END_SRC

*** helm
I've recently started to use =helm= and liking it so far. Below is my
bare minium setup for =helm=.
#+BEGIN_SRC emacs-lisp
      (use-package helm
  :bind
  (("C-M-z" . helm-resume)
   ("C-h b" . helm-descbinds)
   ("C-x C-o" . helm-occur)
   ("M-y" . helm-show-kill-ring)
   ("C-h a" . helm-apropos)
   ("C-h m" . helm-man-woman)
   ("M-g >" . helm-ag-this-file)
   ("M-g ," . helm-ag-pop-stack)
   ("M-g ." . helm-do-grep)
   ("C-x C-i" . helm-semantic-or-imenu)
   ("C-h t" . helm-world-time))
  :idle (progn
          ;;(helm-autoresize-mode 1)
          (helm-mode 1))
  :config
  (progn
    (use-package helm-config)
    (use-package helm-files)
    (use-package helm-grep)
    (use-package helm-man)
    (use-package helm-misc)
    (use-package helm-aliases)
    (use-package helm-elisp)
    (use-package helm-imenu)
    (use-package helm-semantic)
    (use-package helm-ring)
    (use-package helm-bookmark
      :bind (("C-x M-b" . helm-bookmarks)))
    (use-package helm-descbinds
      :init (helm-descbinds-mode t))
    (use-package helm-ag
      :bind ("C-M-s" . helm-ag-this-file))

    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (setq helm-idle-delay 0.1
          helm-exit-idle-delay 0.1
          helm-input-idle-delay 0
          helm-candidate-number-limit 500
          helm-buffers-fuzzy-matching t
          ;; truncate long lines in helm completion
          helm-truncate-lines t
          ;; may be overridden if 'ggrep' is in path (see below)
          helm-grep-default-command
          "grep -a -d skip %e -n%cH -e %p %f"
          helm-grep-default-recurse-command
          "grep -a -d recurse %e -n%cH -e %p %f"
          ;; scroll 4 lines other window using M-<next>/M-<prior>
          helm-scroll-amount 4
          ;; do not display invisible candidates
          helm-quick-update t
          ;; be idle for this many seconds, before updating in delayed sources.
          helm-idle-delay 0.01
          ;; be idle for this many seconds, before updating candidate buffer
          helm-input-idle-delay 0.01
          ;; open helm buffer in another window
          helm-split-window-default-side 'other
          ;; open helm buffer inside current window, don't occupy whole other window
          helm-split-window-in-side-p t
          ;; limit the number of displayed canidates
          helm-candidate-number-limit 200
          ;; show all candidates when set to 0
          helm-M-x-requires-pattern 0
          ;; don't use recentf stuff in helm-ff
          helm-ff-file-name-history-use-recentf nil
          ;; move to end or beginning of source when reaching top or bottom
          ;; of source
          helm-move-to-line-cycle-in-source t
          ;; sometimes needed in helm-buffers-list
          ido-use-virtual-buffers 'auto
          ;; fuzzy matching for helm-M-x
          helm-M-x-fuzzy-match t
          ;; fuzzy matching
          helm-buffers-fuzzy-matching t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-completion-in-region-fuzzy-match t
          ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
          ;; here to the regular default list
          helm-mini-default-sources '(helm-source-buffers-list
                                      helm-source-recentf
                                      helm-source-bookmarks
                                      helm-source-buffer-not-found))

    ;; List of times to show in helm-world-time
    (setq display-time-world-list '(("Asia/Bangkok" "New Delhi")
                                    ("Europe/London" "London")
                                    ("Australia/Sydney" "Sydney")
                                    ("America/Denver" "Denver")
                                    ("EST5EDT" "Toronto")
                                    ("UTC" "UTC")
                                    ("Europe/Amsterdam" "Amsterdam")
                                    ("Asia/Tokyo" "Tokyo")))
    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    (define-key helm-map (kbd "C-p")   'helm-previous-line)
    (define-key helm-map (kbd "C-n")   'helm-next-line)
    (define-key helm-map (kbd "C-M-n") 'helm-next-source)
    (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
    ;; The normal binding is C-c h M-g s which is insane
    (global-set-key (kbd "C-c h g")    'helm-do-grep)
    (global-set-key (kbd "C-c h a")    'helm-do-ag)

    (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
    (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
    (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)

    (when (executable-find "curl")
      (setq helm-google-suggest-use-curl-p t))

    ;; ggrep is gnu grep on OSX
    (when (executable-find "ggrep")
      (setq helm-grep-default-command
            "ggrep -a -d skip %e -n%cH -e %p %f"
            helm-grep-default-recurse-command
            "ggrep -a -d recurse %e -n%cH -e %p %f"))

    (define-key helm-map (kbd "C-x 2") 'helm-select-2nd-action)
    (define-key helm-map (kbd "C-x 3") 'helm-select-3rd-action)
    (define-key helm-map (kbd "C-x 4") 'helm-select-4rd-action)

    ;; helm-mini instead of recentf
    (define-key 'help-command (kbd "C-f") 'helm-apropos)
    (define-key 'help-command (kbd "r") 'helm-info-emacs)

    ;; use helm to list eshell history
    (add-hook 'eshell-mode-hook
              #'(lambda ()
                  (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))

    ;; Save current position to mark ring
    (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)

    (defvar helm-httpstatus-source
      '((name . "HTTP STATUS")
        (candidates . (("100 Continue") ("101 Switching Protocols")
                       ("102 Processing") ("200 OK")
                       ("201 Created") ("202 Accepted")
                       ("203 Non-Authoritative Information") ("204 No Content")
                       ("205 Reset Content") ("206 Partial Content")
                       ("207 Multi-Status") ("208 Already Reported")
                       ("300 Multiple Choices") ("301 Moved Permanently")
                       ("302 Found") ("303 See Other")
                       ("304 Not Modified") ("305 Use Proxy")
                       ("307 Temporary Redirect") ("400 Bad Request")
                       ("401 Unauthorized") ("402 Payment Required")
                       ("403 Forbidden") ("404 Not Found")
                       ("405 Method Not Allowed") ("406 Not Acceptable")
                       ("407 Proxy Authentication Required") ("408 Request Timeout")
                       ("409 Conflict") ("410 Gone")
                       ("411 Length Required") ("412 Precondition Failed")
                       ("413 Request Entity Too Large")
                       ("414 Request-URI Too Large")
                       ("415 Unsupported Media Type")
                       ("416 Request Range Not Satisfiable")
                       ("417 Expectation Failed") ("418 I'm a teapot")
                       ("422 Unprocessable Entity") ("423 Locked")
                       ("424 Failed Dependency") ("425 No code")
                       ("426 Upgrade Required") ("428 Precondition Required")
                       ("429 Too Many Requests")
                       ("431 Request Header Fields Too Large")
                       ("449 Retry with") ("500 Internal Server Error")
                       ("501 Not Implemented") ("502 Bad Gateway")
                       ("503 Service Unavailable") ("504 Gateway Timeout")
                       ("505 HTTP Version Not Supported")
                       ("506 Variant Also Negotiates")
                       ("507 Insufficient Storage") ("509 Bandwidth Limit Exceeded")
                       ("510 Not Extended")
                       ("511 Network Authentication Required")))
        (action . message)))

    (defvar helm-clj-http-source
      '((name . "clj-http options")
        (candidates
         .
         ((":accept - keyword for content type to accept")
          (":as - output coercion: :json, :json-string-keys, :clojure, :stream, :auto or string")
          (":basic-auth - string or vector of basic auth creds")
          (":body - body of request")
          (":body-encoding - encoding type for body string")
          (":client-params - apache http client params")
          (":coerce - when to coerce response body: :always, :unexceptional, :exceptional")
          (":conn-timeout - timeout for connection")
          (":connection-manager - connection pooling manager")
          (":content-type - content-type for request")
          (":cookie-store - CookieStore object to store/retrieve cookies")
          (":cookies - map of cookie name to cookie map")
          (":debug - boolean to print info to stdout")
          (":debug-body - boolean to print body debug info to stdout")
          (":decode-body-headers - automatically decode body headers")
          (":decompress-body - whether to decompress body automatically")
          (":digest-auth - vector of digest authentication")
          (":follow-redirects - boolean whether to follow HTTP redirects")
          (":form-params - map of form parameters to send")
          (":headers - map of headers")
          (":ignore-unknown-host? - whether to ignore inability to resolve host")
          (":insecure? - boolean whether to accept invalid SSL certs")
          (":json-opts - map of json options to be used for form params")
          (":keystore - file path to SSL keystore")
          (":keystore-pass - password for keystore")
          (":keystore-type - type of SSL keystore")
          (":length - manually specified length of body")
          (":max-redirects - maximum number of redirects to follow")
          (":multipart - vector of multipart options")
          (":oauth-token - oauth token")
          (":proxy-host - hostname of proxy server")
          (":proxy-ignore-hosts - set of hosts to ignore for proxy")
          (":proxy-post - port for proxy server")
          (":query-params - map of query parameters")
          (":raw-headers - boolean whether to return raw headers with response")
          (":response-interceptor - function called for each redirect")
          (":retry-handler - function to handle HTTP retries on IOException")
          (":save-request? - boolean to return original request with response")
          (":socket-timeout - timeout for establishing socket")
          (":throw-entire-message? - whether to throw the entire response on errors")
          (":throw-exceptions - boolean whether to throw exceptions on 5xx & 4xx")
          (":trust-store - file path to trust store")
          (":trust-store-pass - password for trust store")
          (":trust-store-type - type of trust store")))
        (action . message)))

    (defun helm-httpstatus ()
      (interactive)
      (helm-other-buffer '(helm-httpstatus-source) "*helm httpstatus*"))

    (defun helm-clj-http ()
      (interactive)
      (helm-other-buffer '(helm-clj-http-source) "*helm clj-http flags*"))

    (global-set-key (kbd "C-c M-C-h") 'helm-httpstatus)
    (global-set-key (kbd "C-c M-h") 'helm-clj-http)

    (use-package helm-swoop
      :bind (("M-i" . helm-swoop)
             ("M-I" . helm-swoop-back-to-last-point)
             ("C-c M-i" . helm-multi-swoop))
      :config
      (progn
        ;; When doing isearch, hand the word over to helm-swoop
        (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
        ;; From helm-swoop to helm-multi-swoop-all
        (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
        ;; Save buffer when helm-multi-swoop-edit complete
        (setq helm-multi-swoop-edit-save t
              ;; If this value is t, split window inside the current window
              helm-swoop-split-with-multiple-windows nil
              ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
              helm-swoop-split-direction 'split-window-vertically
              ;; If nil, you can slightly boost invoke speed in exchange for text color
              helm-swoop-speed-or-color nil)))))
#+END_SRC
*** smex
Smex is IDO, but for =M-x=

#+BEGIN_SRC emacs-lisp
(use-package smex
  :bind (("M-x" . smex)
         ("M-X" . smex-major-mode-commands)))
#+END_SRC
*** anzu mode
[[https://github.com/syohex/emacs-anzu][anzu.el]] is an Emacs port of =anzu.vim=. It provides a minor mode
which displays current match and total matches information in the
mode-line in various search modes.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind ("M-%" . anzu-query-replace-regexp)
  :config
  (progn
    (use-package thingatpt)
    (setq anzu-mode-lighter "")
    (set-face-attribute 'anzu-mode-line nil :foreground "yellow")))

(add-hook 'prog-mode-hook (lambda () (anzu-mode t)))
#+END_SRC

Also, add a thing for yanking the entire symbol into the query while searching:

#+BEGIN_SRC emacs-lisp
(defun isearch-yank-symbol ()
  (interactive)
  (isearch-yank-internal (lambda () (forward-symbol 1) (point))))

(define-key isearch-mode-map (kbd "C-M-w") 'isearch-yank-symbol)
#+END_SRC

*** Ibuffer mode
=Ibuffer= is an advanced replacement for BufferMenu, which lets you
operate on buffers much in the same manner as Dired.
#+BEGIN_SRC emacs-lisp
  ;; ibuffer
  (use-package ibuffer
    :config (add-hook 'ibuffer-mode-hook (lambda () (setq truncate-lines t)))
    :bind ("C-x C-b" . ibuffer))
#+END_SRC
*** winner mode
winner-mode lets you use =C-c <left>= and =C-c <right>= to switch
between window configurations. This is handy when something has popped
up a buffer that you want to look at briefly before returning to
whatever you were working on. When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :ensure t
    :defer t
    :idle (winner-mode 1))
#+END_SRC
** Window management
*** popwin
Popwin handles little popup windows at the bottom of the screen, which is 
very helpful for documentation buffers and so on.
#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :idle (popwin-mode 1)
    :config
    (progn
      (add-hook 'popwin:before-popup-hook
                (lambda () (setq neo-persist-show nil)))
      (add-hook 'popwin:after-popup-hook
                (lambda () (setq neo-persist-show t)))))

  (defvar popwin:special-display-config-backup popwin:special-display-config)
  (setq display-buffer-function 'popwin:display-buffer)

  ;; basic
  (push '("*Help*" :stick t :noselect t) popwin:special-display-config)
  (push '("*helm world time*" :stick t :noselect t) popwin:special-display-config)
  (push '("*Pp Eval Output*" :stick t) popwin:special-display-config)
  (push '("*Helm Swoop*" :stick t :noselect t) popwin:special-display-config)

  ;; company
  (push '("*company-documentation*" :stick t) popwin:special-display-config)
  ;; magit
  (push '("*magit-process*" :stick t) popwin:special-display-config)

  ;; quickrun
  (push '("*quickrun*" :stick t) popwin:special-display-config)

  ;; dictionaly
  (push '("*dict*" :stick t) popwin:special-display-config)
  (push '("*sdic*" :stick t) popwin:special-display-config)

  ;; popwin for slime
  (push '(slime-repl-mode :stick t) popwin:special-display-config)

  ;; man
  (push '(Man-mode :stick t :height 20) popwin:special-display-config)

  ;; Elisp
  (push '("*ielm*" :stick t) popwin:special-display-config)
  (push '("*eshell pop*" :stick t) popwin:special-display-config)

  ;; pry
  (push '(inf-ruby-mode :stick t :height 20) popwin:special-display-config)

  ;; python
  (push '("*Python*"   :stick t) popwin:special-display-config)
  (push '("*Python Help*" :stick t :height 20) popwin:special-display-config)
  (push '("*jedi:doc*" :stick t :noselect t) popwin:special-display-config)

  ;; Haskell
  (push '("*haskell*" :stick t) popwin:special-display-config)
  (push '("*GHC Info*") popwin:special-display-config)

  ;; sgit
  (push '("*sgit*" :position right :width 0.5 :stick t)
        popwin:special-display-config)

  ;; git-gutter
  (push '("*git-gutter:diff*" :width 0.5 :stick t)
        popwin:special-display-config)

  ;; direx
  (push '(direx:direx-mode :position left :width 40 :dedicated t)
        popwin:special-display-config)

  (push '("*Occur*" :stick t) popwin:special-display-config)

  ;; prodigy
  (push '("*prodigy*" :stick t) popwin:special-display-config)

  ;; malabar-mode
  (push '("*Malabar Compilation*" :stick t :height 30)
        popwin:special-display-config)

  ;; org-mode
  (push '("*Org tags*" :stick t :height 30)
        popwin:special-display-config)

  ;; Completions
  (push '("*Completions*" :stick t :noselect t) popwin:special-display-config)

  ;; ggtags
  (push '("*ggtags-global*" :stick t :noselect t :height 30) popwin:special-display-config)

  ;; async shell commands
  (push '("*Async Shell Command*" :stick t) popwin:special-display-config)
#+END_SRC
** File manager and file system
*** General settings
Open empty file quietly.
#+BEGIN_SRC emacs-lisp
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

Follow sysmlinks.
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC
*** Dired settings
Dired is sweet, I require =dired-x= also so I can hit =C-x C-j=
and go directly to a dired buffer.

Setting =ls-lisp-dirs-first= means directories are always at the
top. Always copy and delete recursively. Also enable
=hl-line-mode= in dired, since it's easier to see the cursor then.

To start, a helper to use "=open=" to open files in dired-mode with =M-o=
(similar to Finder in OSX).

#+BEGIN_SRC emacs-lisp
  (defun my/dired-mac-open ()
    (interactive)
    (save-window-excursion
      (dired-do-async-shell-command
       "open" current-prefix-arg
       (dired-get-marked-files t current-prefix-arg))))
#+END_SRC

And then some other things to setup when dired runs. =C-x C-q= to edit
writable-dired mode is aawwweeeesssoooommee, it makes renames super easy.

#+BEGIN_SRC emacs-lisp
  (defun my/dired-mode-hook ()
    (hl-line-mode t)
    (toggle-truncate-lines 1))

  (use-package dired
    :bind ("C-x C-j" . dired-jump)
    :config
    (progn
      (use-package dired-x
        :init (setq-default dired-omit-files-p t)
        :config
        (when (eq system-type 'darwin)
          (add-to-list 'dired-omit-extensions ".DS_Store")))
      (customize-set-variable 'diredp-hide-details-initially-flag nil)
      (use-package dired-async)
      (put 'dired-find-alternate-file 'disabled nil)
      (setq ls-lisp-dirs-first t
            dired-recursive-copies 'always
            dired-recursive-deletes 'always
            dired-dwim-target t
            delete-by-moving-to-trash t
            wdired-allow-to-change-permissions t)
      (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)
      (define-key dired-mode-map (kbd "C-M-u") 'dired-up-directory)
      (define-key dired-mode-map (kbd "C-x C-q") 'wdired-change-to-wdired-mode)
      (add-hook 'dired-mode-hook #'my/dired-mode-hook)))
#+END_SRC
*** Neo tree
A emacs tree plugin like NERD tree for Vim.
#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :bind (("<f8>" . neotree-toggle))
    :config
    (progn
      ;; key bindings
      (define-key neotree-mode-map (kbd ".") 'neotree-create-node)
      (define-key neotree-mode-map (kbd "d") 'neotree-delete-node)
      (define-key neotree-mode-map (kbd "r") 'neotree-rename-node)
      (define-key neotree-mode-map (kbd "c") 'neotree-change-root)))
#+END_SRC
** Programming languages
Configuration options for language-specific packages live here.
*** General prog-mode hooks
In programming mode make sure:
1. FIXME and TODO are highlighted
2. =linum= mode is turned on 
3. =hl-line= is turned on

In programming mode, I use =C-c c= to comment and un-comment the 
selected region.
#+BEGIN_SRC emacs-lisp
  ;; comment/uncomment line/region
  (defun sk/comment-or-uncomment-region-or-line ()
    "Comments or uncomments the region or the current line if there's no active region."
    (interactive)
    (let (beg end)
      (if (region-active-p)
          (setq beg (region-beginning) end (region-end))
        (setq beg (line-beginning-position) end (line-end-position)))
      (comment-or-uncomment-region beg end)))

  (defun sk/init-prog-mode ()
    "Intialize programming mode"
    (font-lock-add-keywords
     nil '(("\\<\\(FIXME\\|TODO\\)\\>"
            1 '((:foreground "#d7a3ad") (:weight bold)) t)))
    ;; enables some modes for programming
    (linum-mode t)
    (hl-line-mode t)
    (company-mode t)
    ;; key bind
    (define-key prog-mode-map (kbd "C-c c") 'sk/comment-or-uncomment-region-or-line))

  (add-hook 'prog-mode-hook 'sk/init-prog-mode)
#+END_SRC

*** Shell
I turned off show-paren-mode (I have show-smartparen-mode anyway) and
flycheck (I don't want to run it!) as well as not blinking the
matching paren.

#+BEGIN_SRC emacs-lisp
(add-hook 'sh-mode-hook
          (lambda ()
            (show-paren-mode -1)
            (flycheck-mode -1)
            (setq blink-matching-paren nil)))
#+END_SRC

*** Elisp
This contains the configuration for elisp programming

First, turn on eldoc everywhere it's useful:

#+BEGIN_SRC emacs-lisp
(defun my/turn-on-paredit-and-eldoc ()
  (interactive)
  (paredit-mode 1)
  (eldoc-mode 1))

(add-hook 'emacs-lisp-mode-hook #'my/turn-on-paredit-and-eldoc)
(add-hook 'ielm-mode-hook #'my/turn-on-paredit-and-eldoc)
#+END_SRC

And some various eldoc settings:

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :config
  (progn
    (use-package diminish
      :init
      (progn (diminish 'eldoc-mode "ed")))
    (setq eldoc-idle-delay 0.3)
    (set-face-attribute 'eldoc-highlight-function-argument nil
                        :underline t :foreground "green"
                        :weight 'bold)))
#+END_SRC

Change the faces for elisp regex grouping:

#+BEGIN_SRC emacs-lisp
(set-face-foreground 'font-lock-regexp-grouping-backslash "#ff1493")
(set-face-foreground 'font-lock-regexp-grouping-construct "#ff8c00")
#+END_SRC

Define some niceties for popping up an ielm buffer:

#+BEGIN_SRC emacs-lisp
(defun ielm-other-window ()
  "Run ielm on other window"
  (interactive)
  (switch-to-buffer-other-window
   (get-buffer-create "*ielm*"))
  (call-interactively 'ielm))

(define-key emacs-lisp-mode-map (kbd "C-c C-z") 'ielm-other-window)
(define-key lisp-interaction-mode-map (kbd "C-c C-z") 'ielm-other-window)
#+END_SRC

Turn on elisp-slime-nav if available, so =M-.= works to jump to function
definitions:

#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode))
#+END_SRC

Borrowed from Steve Purcell's config. This pretty-prints the results.

#+begin_src emacs-lisp
(bind-key "M-:" 'pp-eval-expression)

(defun sanityinc/eval-last-sexp-or-region (prefix)
 "Eval region from BEG to END if active, otherwise the last sexp."
 (interactive "P")
 (if (and (mark) (use-region-p))
 (eval-region (min (point) (mark)) (max (point) (mark)))
 (pp-eval-last-sexp prefix)))

(bind-key "C-x C-e" 'sanityinc/eval-last-sexp-or-region emacs-lisp-mode-map)
#+end_src

*** Python
I use [[https://github.com/jorgenschaefer/elpy][elpy]] as my Emacs Python development environment. Use
=elpy-config= to configure completion, syntax
checker, =linter= back-ends.

I use =virtualenv= and =virtualenvwrapper= to isolate my Python
environment for different kind of projects (research, web, general
purpose and Python 2).

For Python projects, I keep =.pyvenv= file in project's root folder
which contains the name of the Python environment configured for that
project. My Emacs automatically load the Python environment by reading
=.pyvenv= file.

#+BEGIN_SRC emacs-lisp
  (defun sk/python-project-pyvenv-name()
    (interactive)
    "Read the name of Python evironment associated with the project"
    (condition-case nil
        (let* ((pyvenv-file (concat (projectile-project-root) ".pyvenv"))
               (pyvenv-file-content (f-read pyvenv-file 'utf-8)))
          (replace-regexp-in-string "\n$" "" pyvenv-file-content))
      (error nil)))

  (defun sk/python-switch-pyvenv-for-project()
    (interactive)
    "Switch to the Python environment asscoiated with the project"
    (let ((pyvenv-name (sk/python-project-pyvenv-name)))
      (message pyvenv-name)
      ;; if Python environment is not null
      (if (and
           pyvenv-name
           (not (string-equal pyvenv-name pyvenv-virtual-env-name)))
          (pyvenv-workon pyvenv-name))))
#+END_SRC

Function below helps me select Python environment interatcively though
=ido= completion. It is bound to =C-c C-e= within =elpy= mode.

#+BEGIN_SRC emacs-lisp
  (defun sk/ido-pyvenv-workon()
    "Use `ido-completing-read' to \\[pyvenv-workon] a Python environments"
    (interactive)
    (pyvenv-workon
     (ido-completing-read
      (format "Work on (%s): " pyvenv-virtual-env-name)
      (pyvenv-virtualenv-list))))
#+END_SRC

I use =IPython= as my default Python shell for debugging and
interactive sessions. I've bound =C-c C-d= to toggle the breakpoint in
my Python buffer (it uses =ipdb.set_trace()= function).

#+BEGIN_SRC emacs-lisp
  (defface python-debugging-line-face
    '((t (:inherit hl-line
                   :background "dark red"
                   :foreground "white"
                   :weight bold)))
    "Face for ipdb line in Python")

  ;; taken from:
  ;; http://jack-kelly.com/setting_up_emacs_for_python_development
  (defun sk/python-toggle-breakpoint ()
    (interactive)
    (let* ((current-line (thing-at-point 'line))
           (ipdb-line "import ipdb; ipdb.set_trace()")
           (ipdb-regex-line (concat "^[ ]*" ipdb-line)))
      (if (string-match ipdb-regex-line current-line)
          (delete-region (line-beginning-position) (+ (line-end-position) 1))
        (save-excursion
          (move-beginning-of-line 1)
          (indent-according-to-mode)
          (insert ipdb-line)
          (newline-and-indent)
          (highlight-lines-matching-regexp ipdb-regex-line 'python-debugging-line-face)))))

#+END_SRC

Setting up =elpy= and configuring all keybindings.

#+BEGIN_SRC emacs-lisp
  (defun sk/python-mode-init ()
    ;; disable flycheck here
    (flycheck-mode -1)
    (sk/python-switch-pyvenv-for-project)
    (highlight-lines-matching-regexp "^[ ]*import ipdb; ipdb.set_trace()"
                                     'python-debugging-line-face))

  (use-package elpy
    :config
    (progn
      (add-hook 'python-mode-hook 'sk/python-mode-init)
      ;; use ido to switch between environments
      (define-key elpy-mode-map (kbd "C-c C-e") 'sk/ido-pyvenv-workon)
      (define-key elpy-mode-map (kbd "C-c C-d") 'sk/python-toggle-breakpoint)
      (elpy-enable)
      (elpy-use-ipython)))

#+END_SRC

#+BEGIN_SRC python
print("hello")
#+END_SRC
*** Javascript
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
      (defalias 'javascript-generic-mode 'js2-mode))
    :config
    (progn
      (js2-imenu-extras-setup)
      (setq-default js-auto-indent-flag nil
                    js-indent-level 2)
      (use-package tern
        :defer t
        :config
        (progn
          (add-hook 'js2-mode-hook (lambda () (tern-mode t)))
          (add-to-list 'company-backends 'company-tern)))))


#+END_SRC

There's =tern= also, but I leave it turned off by default

#+BEGIN_SRC emacs-lisp
(use-package tern
  :init ;;(add-hook 'js-mode-hook (lambda () (tern-mode t)))
  )
#+END_SRC
*** Csharp
#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :config
    (progn
      (use-package omnisharp
        :config
        (progn
          (setq omnisharp-server-executable-path
                "/home/shivamk/src/omnisharp-server/OmniSharp/bin/Debug/OmniSharp.exe")))
      (add-hook 'csharp-mode-hook 'omnisharp-mode)))
#+END_SRC
** More programming
*** How do I
Get code snippet from natural language text.
#+BEGIN_SRC emacs-lisp
  (use-package howdoi
    :defer t
    :bind (("C-c q l" . howdoi-query-line-at-point-replace-by-code-snippet)
           ("C-c q f" . howdoi-query-line-at-point)))
#+END_SRC
** Editing
*** Auto fill mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook
            (lambda ()
              (auto-fill-mode t)
              (set-fill-column 80)))
#+END_SRC
*** multiple-cursors
Mulitple cursors is like rectangular selection/insertion but on steroids

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)))
#+END_SRC
*** undo-tree
Undo-tree allows me to have sane undo defaults, as well as being able to
visualize it in ascii art if needed.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :idle (global-undo-tree-mode t)
  :diminish ""
  :config
  (progn
    (define-key undo-tree-map (kbd "C-x u") 'undo-tree-visualize)
    (define-key undo-tree-map (kbd "C-/") 'undo-tree-undo)))
#+END_SRC
*** smartparens
So, paredit is great, however, it doesn't work for non-lisp modes. Smartparens
works pretty well, so I use it everywhere paredit-mode doesn't work.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind (("M-9" . sp-backward-sexp)
         ("M-0" . sp-forward-sexp))
  :config
  (progn
    (add-to-list 'sp-sexp-suffix '(json-mode regex ""))
    (add-to-list 'sp-sexp-suffix '(es-mode regex ""))

    (use-package smartparens-config)
    (add-hook 'sh-mode-hook
              (lambda ()
                ;; Remove when https://github.com/Fuco1/smartparens/issues/257
                ;; is fixed
                (setq sp-autoescape-string-quote nil)))

    ;; Remove the M-<backspace> binding that smartparens adds
    (let ((disabled '("M-<backspace>")))
      (setq sp-smartparens-bindings
            (cl-remove-if (lambda (key-command)
                            (member (car key-command) disabled))
                          sp-smartparens-bindings)))

    (define-key sp-keymap (kbd "C-(") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "C-)") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "M-(") 'sp-forward-barf-sexp)
    (define-key sp-keymap (kbd "M-)") 'sp-forward-slurp-sexp)
    (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
    (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
    (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)
    (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
    (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
    (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
    (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)
    (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
    (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
    (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)
    ;; (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
    ;; (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)
    (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
    (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)
    (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
    (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
    (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
    (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)
    (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
    (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)
    (define-key sp-keymap (kbd "H-t") 'sp-prefix-tag-object)
    (define-key sp-keymap (kbd "H-p") 'sp-prefix-pair-object)
    (define-key sp-keymap (kbd "H-s c") 'sp-convolute-sexp)
    (define-key sp-keymap (kbd "H-s a") 'sp-absorb-sexp)
    (define-key sp-keymap (kbd "H-s e") 'sp-emit-sexp)
    (define-key sp-keymap (kbd "H-s p") 'sp-add-to-previous-sexp)
    (define-key sp-keymap (kbd "H-s n") 'sp-add-to-next-sexp)
    (define-key sp-keymap (kbd "H-s j") 'sp-join-sexp)
    (define-key sp-keymap (kbd "H-s s") 'sp-split-sexp)

    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil)
    ;; Remove '' pairing in elisp because quoting is used a ton
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)

    (sp-with-modes '(html-mode sgml-mode)
      (sp-local-pair "<" ">"))

    (sp-with-modes sp--lisp-modes
      (sp-local-pair "(" nil :bind "C-("))))


(add-hook 'prog-mode-hook
          (lambda ()
            (smartparens-global-mode t)
            (show-smartparens-global-mode t)))
#+END_SRC
** Version control
*** magit
I use =M-g M-g= everywhere to go directly to Magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("M-g M-g" . magit-status)
    :config
    (progn
      ;; longer commit summaries
      (setq git-commit-summary-max-length 72)
      (defun magit-browse ()
        "Browse to the project's github URL, if available"
        (interactive)
        (let ((url (with-temp-buffer
                     (unless (zerop (call-process-shell-command
                                     "git remote -v" nil t))
                       (error "Failed: 'git remote -v'"))
                     (goto-char (point-min))
                     (when (re-search-forward
                            "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                       (format "https://github.com/%s" (match-string 1))))))
          (unless url
            (error "Can't find repository URL"))
          (browse-url url)))

      (when (and (boundp 'moe-theme-which-enabled)
                 (eq moe-theme-which-enabled 'dark))
        ;; Moe's magit colors are baaaaaaad
        (set-face-attribute 'magit-item-highlight nil
                            :inherit nil
                            :foreground 'unspecified))

      (define-key magit-mode-map (kbd "C-c C-b") 'magit-browse)
      (define-key magit-status-mode-map (kbd "W") 'magit-toggle-whitespace)
      (custom-set-variables '(magit-set-upstream-on-push (quote dontask)))
      (setq magit-completing-read-function 'magit-ido-completing-read)
      ;; Diminish the auto-revert-mode
      (add-hook 'magit-auto-revert-mode-hook
                (diminish 'magit-auto-revert-mode))))
#+END_SRC
*** git-gutter
Only enabled in a few modes, but quite useful, as well as the =C-x n= and =C-x
p= bindings.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :bind (("C-x =" . git-gutter:popup-hunk)
           ("C-x p" . git-gutter:previous-hunk)
           ("C-x n" . git-gutter:next-hunk)
           ("C-x v s" . git-gutter:stage-hunk)
           ("C-x v r" . git-gutter:revert-hunk)
           ("C-x v =" . git-gutter:popup-hunk))
    :diminish
    :init (global-git-gutter-mode t)
    :config (require 'git-gutter-fringe))
#+END_SRC
** Projectile
Per-project navigation

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :init (projectile-global-mode)
    :diminish projectile-mode
    :bind (("C-c p s" . projectile-switch-project)
           ("C-c p a" . projectile-ag)
           ("C-c p g" . projectile-grep))
    :config
    (progn
      ;;(setq projectile-switch-project-action 'projectile-dired)
      (setq projectile-switch-project-action 'neotree-projectile-action)
      (use-package helm-projectile
        :bind (("C-c f" . helm-projectile)
               ("C-c p f" . helm-projectile-find-file)
               ("C-c p g" . helm-projectile-ag)))))
#+END_SRC
** Error Checking
*** Flycheck
Pretty minimally configured, but awesome tool for most dynamic languages.

#+BEGIN_SRC emacs-lisp
  (defun my/flycheck-customize ()
    (interactive)
    (global-set-key (kbd "C-c C-n") 'flycheck-tip-cycle)
    (global-set-key (kbd "C-c C-p") 'flycheck-tip-cycle-reverse))

  (use-package flycheck
    :defer t
    :bind (("M-g M-n" . flycheck-next-error)
           ("M-g M-p" . flycheck-previous-error)
           ("M-g M-=" . flycheck-list-errors))
    :idle (global-flycheck-mode)
    :diminish "fc"
    :config
    (progn
      (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (use-package flycheck-color-mode-line
        :init (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))
      (use-package flycheck-tip
        :config (add-hook 'flycheck-mode-hook #'my/flycheck-customize))))

#+END_SRC
*** Spell check and flyspell
I use hunspell and aspell checking spelling, ignoring words under 3 characters
and running very quickly.

First, set up some Hunspell things if applicable, falling back to aspell if
hunspell isn't available:

#+BEGIN_SRC emacs-lisp
  ;; Standard location of personal dictionary
  ;; (setq ispell-personal-dictionary "~/.flydict")
  (if (file-exists-p "/usr/local/bin/hunspell")
      (progn
        ;; Add english-hunspell as a dictionary
        (setq-default ispell-program-name "hunspell"
                      ispell-dictionary "en_US"))
    (progn (setq-default ispell-program-name "aspell")
           (setq ispell-extra-args '("--sug-mode=normal" "--ignore=3"))))

  (add-to-list 'ispell-skip-region-alist '("[^\000-\377]+"))
#+END_SRC

In most non-programming modes, =M-.= can be used to spellcheck the word
(otherwise it would jump to the definition)

#+BEGIN_SRC emacs-lisp
  ;; flyspell
  (use-package flyspell
    :diminish "FS"
    :config
    (define-key flyspell-mode-map (kbd "M-n") 'flyspell-goto-next-error)
    (define-key flyspell-mode-map (kbd "M-.") 'ispell-word))
#+END_SRC

** Text modes
*** ediff
Ediff is fantastic for looking through diffs, a lot of these settings are taken
from http://oremacs.com/2015/01/17/setting-up-ediff/

#+BEGIN_SRC emacs-lisp
(defun my/setup-ediff ()
  (interactive)
  (ediff-setup-keymap)
  (define-key ediff-mode-map "j" #'ediff-next-difference)
  (define-key ediff-mode-map "k" #'ediff-previous-difference))

(use-package ediff
  :init (add-hook 'ediff-mode-hook 'my/setup-ediff)
  :config
  (progn
    (setq
     ;; Always split nicely for wide screens
     ediff-split-window-function 'split-window-horizontally
     ;; Ignore whitespace
     ediff-diff-options "-w")))
#+END_SRC

*** vlf (view large files)
[[https://github.com/m00natic/vlfi][VLF]] lets me handle things like 2gb files gracefully.

#+BEGIN_SRC emacs-lisp
(use-package vlf-setup)
#+END_SRC
** org-mode
Exporting org-mode to [[http://lab.hakim.se/reveal-js/#/][reveal.js]] presentations

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
  (use-package ox-reveal
    :config
    (progn
      (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/2.5.0/")
      ;; org and windmove
      (add-hook 'org-shiftup-final-hook 'windmove-up)
      (add-hook 'org-shiftleft-final-hook 'windmove-left)
      (add-hook 'org-shiftdown-final-hook 'windmove-down)
      (add-hook 'org-shiftright-final-hook 'windmove-right)))
#+END_SRC

** Completion frameworks
*** Yasnippet
#+BEGIN_SRC emacs-lisp
  ;; yasn\ippet
  (use-package yasnippet
    :defer t
    :config
    (progn
      (yas-global-mode)
      (unbind-key "<tab>" yas-minor-mode-map)
      (unbind-key "TAB" yas-minor-mode-map)
      (bind-key "C-c y" 'yas-expand yas-minor-mode-map)
      (custom-set-variables '(yas/prompt-functions '(my-yas/prompt))))
    :idle (yas-reload-all))
#+END_SRC
*** Company mode
Standard auto-completion configuration with company-mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish " C"
    :bind ("C-." . company-complete)
    :config
    (progn
      (setq company-idle-delay 0.2
            ;; min prefix of 2 chars
            company-minimum-prefix-length 2
            company-selection-wrap-around t
            company-show-numbers t
            company-dabbrev-downcase nil
            company-transformers '(company-sort-by-occurrence))
      (bind-keys :map company-active-map
                 ("C-n" . company-select-next)
                 ("C-p" . company-select-previous)
                 ("C-d" . company-show-doc-buffer)
                 ("<tab>" . company-complete))))
#+END_SRC

*** abbrev
I use abbrev-mode to automatically correct misspellings I usually make.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :diminish ""
  :config
  (progn
    (define-key ctl-x-map "\C-a" 'my/ispell-word-then-abbrev)

    (defun my/ispell-word-then-abbrev (p)
      "Call `ispell-word'. Then create an abbrev for the correction made.
With prefix P, create local abbrev. Otherwise it will be global."
      (interactive "P")
      (let ((bef (downcase (or (thing-at-point 'word) ""))) aft)
        (call-interactively 'ispell-word)
        (setq aft (downcase (or (thing-at-point 'word) "")))
        (unless (string= aft bef)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob"))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft))))

    (setq save-abbrevs t)
    (setq-default abbrev-mode t)))

(defun my/enable-abbrev-mode ()
  (interactive)
  (abbrev-mode t))

(add-hook 'prog-mode-hook #'my/enable-abbrev-mode)
#+END_SRC

From https://github.com/purcell/emacs.d/blob/master/lisp/init-auto-complete.el -
Exclude very large buffers from dabbrev

#+begin_src emacs-lisp
(defun sanityinc/dabbrev-friend-buffer (other-buffer)
 (< (buffer-size other-buffer) (* 1 1024 1024)))
(setq dabbrev-friend-buffer-function 'sanityinc/dabbrev-friend-buffer)
#+end_src

*** smart-tab
Used smart-tab to complete everywhere except for ERC, shell and mu4e.

#+BEGIN_SRC emacs-lisp
(use-package smart-tab
  :diminish ""
  :config
  (progn
    (add-to-list 'smart-tab-disabled-major-modes 'mu4e-compose-mode)
    (add-to-list 'smart-tab-disabled-major-modes 'erc-mode)
    (add-to-list 'smart-tab-disabled-major-modes 'shell-mode)))

(add-hook 'prog-mode-hook (lambda () (global-smart-tab-mode 1)))
#+END_SRC

** eww
Ewwwwww...

Wait, no, I mean the Emacs web browser built in to 24.4

#+BEGIN_SRC emacs-lisp
(use-package eww
  :init
  (progn
    (define-prefix-command 'my/eww-map)
    (define-key ctl-x-map "w" 'my/eww-map)

    (define-key my/eww-map "t" 'eww)
    (define-key my/eww-map "o" 'eww)
    (define-key my/eww-map "w" 'my/eww-wiki)
    (define-key my/eww-map "e" 'my/search-es-docs)

    (defun my/eww-wiki (text)
      "Function used to search wikipedia for the given text."
      (interactive (list (read-string "Wiki for: ")))
      (eww (format "https://en.m.wikipedia.org/wiki/Special:Search?search=%s"
                   (url-encode-url text)))))
  :config
  (progn
    (define-key eww-mode-map "o" 'eww)
    (define-key eww-mode-map "O" 'eww-browse-with-external-browser)
    (use-package eww-lnum
      :init
      (eval-after-load "eww"
        '(progn (define-key eww-mode-map "f" 'eww-lnum-follow)
                (define-key eww-mode-map "F" 'eww-lnum-universal))))))
#+END_SRC
** Utility methods
Various methods I call interactively for things.
*** Recompile startup elisp files
Byte-compile startup stuff.

#+BEGIN_SRC emacs-lisp
  (defun sk/byte-recompile-init-files ()
    "Recompile all of the startup files"
    (interactive)
    (byte-recompile-directory emacs-configuration-directory 0))
#+END_SRC
